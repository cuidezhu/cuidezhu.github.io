<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>老崔博客</title>
    <link>http://ijs.me/</link>
    <description>Recent content on 老崔博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 20 Jul 2018 19:56:36 +0800</lastBuildDate>
    
	<atom:link href="http://ijs.me/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>React 高阶组件和装饰器</title>
      <link>http://ijs.me/2018/07/20/react-higher-order-components-and-decorator/</link>
      <pubDate>Fri, 20 Jul 2018 19:56:36 +0800</pubDate>
      
      <guid>http://ijs.me/2018/07/20/react-higher-order-components-and-decorator/</guid>
      <description>高阶组件 高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。但高阶组件本身并不是React API，它只是一种模式。
下面我们来实现一个高阶组件。</description>
    </item>
    
    <item>
      <title>实现 MVVM 框架的双向数据绑定</title>
      <link>http://ijs.me/2018/07/19/mvvm-two-way-data-binding/</link>
      <pubDate>Thu, 19 Jul 2018 06:55:28 +0800</pubDate>
      
      <guid>http://ijs.me/2018/07/19/mvvm-two-way-data-binding/</guid>
      <description></description>
    </item>
    
    <item>
      <title>实现 react-redux</title>
      <link>http://ijs.me/2018/07/18/react-redux-implementation/</link>
      <pubDate>Wed, 18 Jul 2018 20:45:52 +0800</pubDate>
      
      <guid>http://ijs.me/2018/07/18/react-redux-implementation/</guid>
      <description>前面的文章 迷你 Redux 实现 我们实现了一个简单的 Redux, 那么我们怎么在 React 项目里使用我们自制的 Redux 呢？我们可以显式传递 Store，但更优雅的方式是使用 react-redux，这篇文章会实现我们自己的 react-redux。
显式传递 Store 我们可以手动用 subscribe 订阅 ReactDOM.render 来将把 redux 和 react 结合起来，将 Store 集成到 UI 中最合乎直觉逻辑的做法是显式地将它作为属性在组件树中向下传递。例如下面的 index.js 文件中渲染一个 App 组件并传递 Store:
import React from &#39;react&#39; import ReactDOM from &#39;react-dom&#39; import App from &#39;./components/App&#39; import { counter } from &#39;./index.redux&#39; const store = createStore(counter) const render = () =&amp;gt; ReactDOM.render( &amp;lt;App store={store} /&amp;gt;, document.getElementById(&#39;root&#39;) ) store.subscribe(render) render()  在这个文件中，我们使用 counter 这个 reducer 处理函数来创建了一个 store，当 App 组件渲染完毕后，Store 会作为属性传递给它。每次 Store 发生变化后，render 函数就会被触发执行，这样就可以使用新的 State 数据高效地更新 UI 了。</description>
    </item>
    
    <item>
      <title>Webpack Code Splitting</title>
      <link>http://ijs.me/2018/07/16/webpack-code-splitting/</link>
      <pubDate>Mon, 16 Jul 2018 23:53:36 +0800</pubDate>
      
      <guid>http://ijs.me/2018/07/16/webpack-code-splitting/</guid>
      <description></description>
    </item>
    
    <item>
      <title>React 原理深入解析（附源码）</title>
      <link>http://ijs.me/2018/07/15/react-source-code-analysis/</link>
      <pubDate>Sun, 15 Jul 2018 09:51:10 +0800</pubDate>
      
      <guid>http://ijs.me/2018/07/15/react-source-code-analysis/</guid>
      <description>JSX 我们现在一般使用 JSX 来写 React 代码，实际上我们的 JSX 最终会把编译成普通的 JavaScript 代码，我们可以在 Babel 里看下转化后的代码：
我们可以看到经过 Babel 编译后，React 实际上是调用 createElement() 函数 来创建元素的。
React.createElement() 我们可以看下 React 源码中的 react/packages/react/src/ReactElement.js 文件，找到createElement() 函数，createElement() 接收三个参数，分别是元素的类型，属性，和子元素：
/** * Create and return a new ReactElement of the given type. * See https://reactjs.org/docs/react-api.html#createelement */ export function createElement(type, config, children) { let propName; // Reserved names are extracted const props = {}; let key = null; let ref = null; let self = null; let source = null; if (config !</description>
    </item>
    
    <item>
      <title>迷你 Redux 实现</title>
      <link>http://ijs.me/2018/07/14/mini-redux-implemention/</link>
      <pubDate>Sat, 14 Jul 2018 20:04:01 +0800</pubDate>
      
      <guid>http://ijs.me/2018/07/14/mini-redux-implemention/</guid>
      <description>redux 主要由三部分组成：action, reduer, store，
Action Action 是用户自己定义的，用来描述发生了什么, action 的 type 字段是必须的，其它字段可以自己定义：
const action = { type: &#39;ADD_TODO&#39;, };  Reducer Reducer 也是由用户负责编写的，Reducers 指定了应用状态的变化如何响应 actions 并发送到 store 的，记住 actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state。
function todoApp(state = initialState, action) { switch (action.type) { case ADD_TODO: return state + 1 default: return state } }  Store redux 只有一个单一的 Store, 用户通过 createStore() 来创建 store，createStore() 接受一个 reducer 函数作为参数, 我们使用 combineReducers() 将多个 reducer 合并成为一个。
createStore() 的第二个参数是可选的, 用于设置 state 初始状态。这对开发同构应用时非常有用，服务器端 redux 应用的 state 结构可以与客户端保持一致, 那么客户端可以将从网络接收到的服务端 state 直接用于本地数据初始化。</description>
    </item>
    
    <item>
      <title>单向数据绑定 VS 双向数据绑定</title>
      <link>http://ijs.me/2018/07/13/one-way-data-binding-vs-two-way-data-binding/</link>
      <pubDate>Fri, 13 Jul 2018 19:19:13 +0800</pubDate>
      
      <guid>http://ijs.me/2018/07/13/one-way-data-binding-vs-two-way-data-binding/</guid>
      <description> 单向数据绑定 React 的数据是单向绑定的，不像 Vue 支持双向绑定。相应的 React 中的数据流也是单向的，这也是 React 提倡的一点，单向数据绑定能够避免状态管理复杂度上升时产生的各种问题。试想一下在双向数据绑定中：如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。单向数据绑定可以让应用变得更加可预测且容易理解。
单向数据绑定的优点：
 所有状态的改变可记录、可跟踪，源头易追溯; 所有数据只有一份，组件数据只有唯一的入口和出口，使得程序更直观更容易理解，有利于应用的可维护性; 一旦数据变化，就去更新页面(data-页面)，但是没有(页面-data); 如果用户在页面上做了变动，那么就手动收集起来(双向是自动)，合并到原有的数据中。  双向绑定 = 单向绑定 + UI事件监听
单向数据绑定的缺点：
 HTML代码渲染完成，无法改变，有新数据，就须把旧HTML代码去掉，整合新数据和模板重新渲染; 代码量上升，数据流转过程变长，出现很多类似的样板代码; 同时由于对应用状态独立管理的严格要求(单一的全局store)，在处理局部状态较多的场景时(如用户输入交互较多的“富表单型”应用 TodoMVC等)，会显得啰嗦及繁琐。  双向数据绑定 双向数据绑定带来了双向数据流，数据模型（Module）和视图（View）之间的双向绑定，无论数据变化，或是用户操作，都能带来互相的变动，自动更新，适用于UI控件中（通常是类表单操作）。
双向数据绑定优点：
 用户在视图上的修改会自动同步到数据模型中去，数据模型中值的变化也会立刻同步到视图中去； 无需进行和单向数据绑定的那些CRUD（Create，Retrieve，Update，Delete）操作； 在表单交互较多的场景下，会简化大量业务无关的代码。  双向数据绑定缺点：
 无法追踪局部状态的变化； “暗箱操作”，增加了出错时 debug 的难度； 由于组件数据变化来源入口变得可能不止一个，数据流转方向易紊乱，若再缺乏“管制”手段，血崩。  </description>
    </item>
    
    <item>
      <title>React Router 实现原理 &amp; 动手实现自己的 Router</title>
      <link>http://ijs.me/2018/07/12/react-router-implementation/</link>
      <pubDate>Thu, 12 Jul 2018 23:25:06 +0800</pubDate>
      
      <guid>http://ijs.me/2018/07/12/react-router-implementation/</guid>
      <description></description>
    </item>
    
    <item>
      <title>五种方式实现三栏布局（两边固定宽度，中间自适应）</title>
      <link>http://ijs.me/2018/07/11/html-css-three-column-layout/</link>
      <pubDate>Wed, 11 Jul 2018 23:15:41 +0800</pubDate>
      
      <guid>http://ijs.me/2018/07/11/html-css-three-column-layout/</guid>
      <description>三栏布局是网页中常见的布局，即两边固定宽度，中间自适应，下面我们用五种不同的方式来实现这种布局。</description>
    </item>
    
    <item>
      <title>Apply, Call 和 Bind</title>
      <link>http://ijs.me/2018/07/04/apply-call-bind/</link>
      <pubDate>Wed, 04 Jul 2018 23:58:57 +0800</pubDate>
      
      <guid>http://ijs.me/2018/07/04/apply-call-bind/</guid>
      <description>在 JavaScript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。
let obj = { name: &#39;jack&#39; } function func() { console.log(this.name); } func.call(obj); // &amp;quot;jack&amp;quot;  call 方法的第一个参数是作为函数上下文的对象，这里把 obj 作为参数传给了 func，此时函数里的 this 便指向了 obj 对象。此处 func 函数里其实相当于
function func() { console.log(obj.name); }  call 和 apply 作用相同，只是接收的参数不一样
function.apply(thisArg, [argsArray]) function.call(thisArg, arg1, arg2, ...)  bind() 也可以改变 this 的指向，bind() 方法会创建一个新函数，当这个新函数被调用时，它的 this 值是传递给 bind() 的第一个参数, 它的参数是 bind() 的其他参数和其原本的参数。
apply, call 和 bind 三者有相似之处，
 都是用来改变函数的this对象的指向的。 第一个参数都是this要指向的对象。 都可以利用后续参数传参。  var xw={ name: &amp;quot;小王&amp;quot;, gender: &amp;quot;男&amp;quot;, age: 24, say: function() { alert(this.</description>
    </item>
    
    <item>
      <title>JavaScript 函数防抖 Debounce 实现原理</title>
      <link>http://ijs.me/2018/07/02/javascript-function-debounce/</link>
      <pubDate>Mon, 02 Jul 2018 23:20:48 +0800</pubDate>
      
      <guid>http://ijs.me/2018/07/02/javascript-function-debounce/</guid>
      <description>考虑这样一个场景，我们有一个搜索框，需要在用户输入内容时列出搜索结果，我们可以用 oninput 事件来做这件事情。
oninput 和 onchange 不同之处在于 oninput 事件在 input 值发生变化是立即触发， onchange 在元素失去焦点时触发。
我们想要选用 oninput 来做这件事情，以便即时地获取到搜索的数据。
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;myInput&amp;quot; oninput=&amp;quot;debounceSearch(this)&amp;quot;&amp;gt;  可是用 oninput 会带来一个问题，比如用户想搜索 JavaScript 这个关键字，当用户输入 J 时发送一次请求数据的请求，接着输入 a，又用 Ja这个关键字发送一次请求，在用户输入完 JavaScript 这个关键字的过程中，我们总共发了 10 次请求，而前 9 次请求都是无效的，如果用户输入够快的话，这样就会带给服务器更大的压力，我们可以用函数防抖来解决这个问题。
函数防抖（debounce）就是当我们发送一个请求方法时，我们把请求数据的方法放到 setTimeout() 里，每次发请求之前都先 clearTimeout()，这样用户在 setTimeout() 里规定的 delay 时间里触发 oninput 就会 clearTimeout()，导致不发送请求，直至用户在 delay 时间里无操作，才发送请求。代码简化如下：
let timer; function debounceSearch(e) { let searchKeywords = e.value; clearTimeout(timer); timer = setTimeout(() =&amp;gt; { console.log(searchKeywords); }, 250); }  上面那种方法只是简单的演示下防抖的原理，上面那种方法扩展性较差</description>
    </item>
    
    <item>
      <title>iTerm2 使用 lrzsz 在本机和服务器之间传输文件</title>
      <link>http://ijs.me/2018/07/01/iterm2-zmodem-lrzsz/</link>
      <pubDate>Sun, 01 Jul 2018 02:05:00 +0800</pubDate>
      
      <guid>http://ijs.me/2018/07/01/iterm2-zmodem-lrzsz/</guid>
      <description>我们有时需要在本机和服务器之间传输文件，我们可以通过 scp 命令来传输，但 scp 还是比较麻烦。也可以通过 ftp 来做，但首先我们需要在服务器上搭建 ftp 服务，也是比较麻烦。如果我们是一个自动化部署的项目，自然可以用我们选用的自动化部署方案来进行部署。但有些时候我们只是比如传某个与项目无关文件，这时我们可以用 lrzsz 来简单地通过 rz 和 sz 命令还进行本机和服务器之间的文件传输。
服务器 我服务器使用的是 CentOS 7 系统，这里我通过 yum 命令来安装 lrzsz:
yum install lrzsz  本机 如果你使用的是 Windows，你可以用 Xshell 来登录远程服务器，由于 Xshell 支持 ZModem 协议，所以什么都不用做就可以直接通过 rz 和 sz 命令来传文件了。
如果你使用的是 macOS，并且用了 item2终端，由于 iTerm2 本身不支持 ZModem 协议，所以我们可以通过 iterm2-zmodem 来让 iTerm2 支持 ZModem 协议。
安装 lrzsz 首先，客户端也需要安装 lrzsz
brew install lrzsz  配置 iTerm2 下载并安装脚本
git clone https://github.com/mmastrac/iterm2-zmodem.git cd iterm2-zmodem cp iterm2-recv-zmodem.</description>
    </item>
    
    <item>
      <title>JavaScript 实现快速排序</title>
      <link>http://ijs.me/2018/06/30/javascript-quicksort-recursion-divide/</link>
      <pubDate>Sat, 30 Jun 2018 20:06:11 +0800</pubDate>
      
      <guid>http://ijs.me/2018/06/30/javascript-quicksort-recursion-divide/</guid>
      <description>function quickSort(arr) { let length = arr.length; let pivotIndex = parseInt((length - 1) / 2); let pivot = arr.splice(pivotIndex, 1)[0]; let leftArr = []; let rightArr = []; if (length &amp;lt;= 1) { return arr; } arr.forEach(v =&amp;gt; { if (v &amp;lt; pivot) { leftArr.push(v); } else { rightArr.push(v); } }); return quickSort(leftArr).concat([pivot], quickSort(rightArr)); } let testArr = [3, 5, 1, 7, 9, 10, 30, 28, 19, 6]; console.log(quickSort(testArr))  关于 let pivot = arr.</description>
    </item>
    
    <item>
      <title>统计字符串中的字符重复出现的次数并按次数排序</title>
      <link>http://ijs.me/2018/06/29/counting-duplicates-sort/</link>
      <pubDate>Fri, 29 Jun 2018 20:29:58 +0800</pubDate>
      
      <guid>http://ijs.me/2018/06/29/counting-duplicates-sort/</guid>
      <description>我们有某个字符串 text 假设 text 是由字母和数字组成的，现在我们要统计字符串中的字符重复出现的次数，然后按次数进行排序，输出。
function countDuplicates(text) { let textArr = text.split(&#39;&#39;); let countObj = {}; let resultArr = []; textArr.forEach(v =&amp;gt; { if (countObj[v]) { countObj[v] += 1; } else { countObj[v] = 1; } }) for (let char in countObj) { resultArr.push([char, countObj[char]]); } resultArr.sort((a, b) =&amp;gt; a[1] - b[1]); console.log(resultArr); } let text = &#39;abba222ccxxxd&#39;; countDuplicates(text);  output: [[&amp;quot;d&amp;quot;, 1], [&amp;quot;a&amp;quot;, 2], [&amp;quot;b&amp;quot;, 2], [&amp;quot;c&amp;quot;, 2], [&amp;quot;2&amp;quot;, 3], [&amp;quot;x&amp;quot;, 3]]</description>
    </item>
    
    <item>
      <title>二分查找（JavaScript实现）</title>
      <link>http://ijs.me/2018/06/21/data-structure-algorithm-javascript-binary-search/</link>
      <pubDate>Thu, 21 Jun 2018 20:47:22 +0800</pubDate>
      
      <guid>http://ijs.me/2018/06/21/data-structure-algorithm-javascript-binary-search/</guid>
      <description>二分查找 二分查找是针对的是已经有序的序列，序列是列表和数组的统称， 在 JS 里通常是数组。我们下面来实现下在 JS 数组里二分查找某个元素：
function binarySearch(orderArr, element) { let start = 0; let end = orderArr.length - 1; while (start &amp;lt;= end) { let mid = Math.floor((start + end) / 2); if (element &amp;lt; orderArr[mid]) { end = mid; } else if (element &amp;gt; orderArr[mid]) { start = mid + 1; } else { console.log(&#39;element index is &#39; + mid); return mid; } } console.log(&#39;not found&#39;) return -1; } let a = [0,1,2,3,4,5,6,7,8] binarySearch(a, 2) //output &amp;quot;element index is 2&amp;quot;  这里我们要注意对边界值的判断，因为取中间值 mid 的时候是使用 floor() 向下取整，所以当查找的值大于中间值时我们要对 start 这个变量加 1，因为这时要查找的值肯定不等于中间值，没必要再判断这时的中间值，并且如果不加 1 还会导致遗漏判断尾边界值。</description>
    </item>
    
    <item>
      <title>前端基础知识总结</title>
      <link>http://ijs.me/2018/06/21/frontend-basic-knowledge/</link>
      <pubDate>Thu, 21 Jun 2018 19:58:48 +0800</pubDate>
      
      <guid>http://ijs.me/2018/06/21/frontend-basic-knowledge/</guid>
      <description>首先，我是非常排斥靠记忆东西来应对面试，但是，有时候我们虽然在用一些东西，而面试中问到了我们没有表达出来，或者因为对概念记忆不深，就导致某次面试，记忆卡壳，导致明明自己会的东西也没回答上来，就会导致场面很尴尬，所以好记性不如烂笔头，总结下前端基础知识以备忘。
以下知识不像常见的搬运网上的文章，而是经过了自己的总结和实践。
JavaScript 继承 JS 里最常用的继承方式是原型链继承，通常通过 prototype 关键字来实现，prototype 属性使你有能力向对象添加属性和方法。
function people(name,job,age) { this.name = name; this.job = job; this.age= age; } var bill = new people(&amp;quot;Bill Gates&amp;quot;,&amp;quot;Engineer&amp;quot;,50); people.prototype.salary = null; bill.salary = 20000; console.log(bill.salary); // output 20000  ES6 的 class 也支持用 extends 关键字来实现继承：
class B extends A  我们用 prototype 实现 B 继承 A 的方式 如下：
function A() { this.arr = [1, 2] } function B() { } B.</description>
    </item>
    
    <item>
      <title>React 使用 Promise 等待外部脚本加载完成再执行代码</title>
      <link>http://ijs.me/2018/06/05/react-load-script/</link>
      <pubDate>Tue, 05 Jun 2018 16:09:35 +0800</pubDate>
      
      <guid>http://ijs.me/2018/06/05/react-load-script/</guid>
      <description>有时我们做项目时，需要引入外部的脚本，有些是需要等脚本加载完才可以执行相关的代码。我们在 React 项目中，可以用 Promise 来做这件事儿。
首先需要如下加载脚本的函数：
function loadScript(src) { return new Promise(resolve =&amp;gt; { let tag = document.createElement(&amp;quot;script&amp;quot;) tag.async = true tag.src = src document.body.appendChild(tag) tag.addEventListener(&amp;quot;load&amp;quot;, function() { resolve() }) }) }  当一个资源及其依赖资源已完成加载时，将触发 load 事件。
然后我们在组件的 componentDidMount() 里调用这个函数：
componentDidMount() { Promise.all([ loadScript(&amp;quot;/a.js&amp;quot;), loadScript(&amp;quot;/b.js&amp;quot;), loadScript(&amp;quot;/c.js&amp;quot;) ]).then(() =&amp;gt; { // your code goes here } }  这样我们就实现了先加载完 a.js, b.js, c.js 这三个脚本再执行相关代码，这里我们需要加载三个脚本，用到了 Promise.all(iterable), 这个方法返回一个新的 promise 对象，该 promise 对象在 iterable 参数对象里所有的 promise 对象都成功的时候才会触发成功，一旦有任何一个 iterable 里面的 promise 对象失败则立即触发该 promise 对象的失败。</description>
    </item>
    
    <item>
      <title>在 Emacs 中搭建 Clojure Repl 环境</title>
      <link>http://ijs.me/2018/06/02/spacemacs-clojure-repl/</link>
      <pubDate>Sat, 02 Jun 2018 23:34:49 +0800</pubDate>
      
      <guid>http://ijs.me/2018/06/02/spacemacs-clojure-repl/</guid>
      <description>安装 Spacemacs 首先安装 Emacs:
brew install emacs --with-cocoa  --with-cocoa 即为安装带有 GUI (图形界面)的 Emacs.
如果你之前使用过 Emacs, 家目录已经有 .emacs.d 的配置文件了，可以先备份：
cd ~ mv .emacs.d .emacs.d.bak mv .emacs .emacs.bak  然后下载 Spacemacs 配置文件：
git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d  然后打开 Emacs 图形界面应用程序，这里为什么不在终端中打开 Emacs 呢，因为 Spacemacs 本身就是为 GUI 而设计的，在终端中打开的话，就连 Spacemacs 的 Logo 都会乱码。直接在终端中输入 emacs 打开的就是 GUI 版的 Emacs 了，然后按照提示回答三个问题，让你选择风格的，我习惯用 Vim， 三个问题我选的都是第一项。然后就可以安装了，耐心等待安装完全部的插件，Spacemacs 就安装好了。这样 Spacemacs 就可以使用 vim 的很多快捷键来使用 Emacs 了，结合了 Emacs 和 Vim 的优点。
安装 Leiningen Leiningen 是用来自动化生成 Clojure 项目，官方使用的安装方法稍微麻烦，我们直接通过 Homebrew 来安装 Leiningen:</description>
    </item>
    
    <item>
      <title>React Redux Devtools 导致 Chrome 之外的浏览器报错处理</title>
      <link>http://ijs.me/2018/05/30/react-redux-devtools/</link>
      <pubDate>Wed, 30 May 2018 08:21:44 +0800</pubDate>
      
      <guid>http://ijs.me/2018/05/30/react-redux-devtools/</guid>
      <description>用 Redux 配合 React 开发项目时遇到一个奇怪的问题，项目只能在 Chrome 浏览器下正确运行，其它的浏览器都会报如下错误：TypeError: undefined is not an object (evaluating &#39;b.apply&#39;)
猜测可能是由 Redux 引起的，于是搜索一番，找到了这个 Github Issues, 原来是因为只有我的 Chrome 浏览器装了 Redux DevTools 这个插件，而其它浏览器都没装，所以下面的代码会报错，
const store = createStore(reducers, compose( applyMiddleware(thunk), window.__REDUX_DEVTOOLS_EXTENSION__ &amp;amp;&amp;amp; window.__REDUX_DEVTOOLS_EXTENSION__() ))  正确的做法是：
const store = createStore(reducers, compose( applyMiddleware(thunk), window.devToolsExtension ? window.devToolsExtension() : f=&amp;gt;f ))  这样项目就不会在 Chrome 之外的浏览器报错了。</description>
    </item>
    
    <item>
      <title>调整 Github 首页布局</title>
      <link>http://ijs.me/2018/05/18/github-index-layout/</link>
      <pubDate>Fri, 18 May 2018 08:28:02 +0800</pubDate>
      
      <guid>http://ijs.me/2018/05/18/github-index-layout/</guid>
      <description>GitHub 首页的改版好蛋疼，原先的右栏换成了左栏，左栏换成了右栏。看着好别扭，原先的看习惯了，于是想把 Github 的首页布局改回去。
更新： 发现用 Stylish-为任意网站自定义主题 更方便，Stylish 改变 UI 时不会闪一下，而且Stylish支持正则表达式匹配网址。
下载好Stylish后，点插件图标，然后点右上角的菜单图标，新建样式，
然后把下面这行 css 复制到代码部分，
.column { float: right; }  底部应用对象选择：与该正则表达式匹配的网址，input框里填入 https://github.com/(orgs/.*|$) 然后点保存就好了。
旧方法 首先我是用的 Chrome 浏览器，下载 Tampermonkey ,Tampermonkey 也有其它浏览器版本，可以去 官网 下载你使用的浏览器对应版本。然后打开GitHub首页，点击插件图标，点添加新脚本。
在新打开的页面中，添加下面一行代码：
document.getElementsByClassName(&#39;column&#39;)[0].style.float=&amp;quot;right&amp;quot;  改下 @match, 在https://github.com/ 后添加 *, 由于 @match 应该是不支持正则表达式中的 ?, 只支持个通配符 * match_patterns, 所以想匹配 https://github.com/orgs/xxx 其中xxx代表任意字符只能加个 * 了，不过这样做满足了匹配首页和 orgs 页面的要求，由于其它页面并没有 column 这个 class,所以对其它页面无影响。
按 Ctrl + S 保存，然后就可以看到 Github 首页布局恢复了。
完整的代码如下:
// ==UserScript== // @name New Userscript // @namespace http://tampermonkey.</description>
    </item>
    
    <item>
      <title>Axios CancelToken 取消请求</title>
      <link>http://ijs.me/2018/05/11/axios-canceltoken/</link>
      <pubDate>Fri, 11 May 2018 13:26:11 +0800</pubDate>
      
      <guid>http://ijs.me/2018/05/11/axios-canceltoken/</guid>
      <description>背景 项目所用的前端框架为React，不过下面所讲的场景和React没啥关系，其他前端架构也会有类似问题。
假如说页面中有两项菜单可供选择，这两项菜单下的内容是同一个页面，同一个组件，两项菜单下的页面结构是一样的，只是数据不同，数据比如都是使用 axios 请求 REST API 获取到的，然后用 setState 把 API 传过来的值展示到页面中。
axios.get(&#39;/test&#39;, { params: { type: &#39;fruit&#39; } }) .then(function (res) { if (res.status === 200) { this.setState({ data: res.data } } })  项目初次加载和点击菜单选项时都会执行类似于上面的请求 API 的方法。
正常点击切换两项菜单时问题不大，能正确展示数据，当我点击很快时，由于向 API 请求数据需要时间，就可能把某次请求pending，然后 setState 就可能会把比如第一个菜单项下的内容展示到第二个菜单下。
解决方案 按钮点击很快这件事本身可以做处理，但我感觉限流也是权宜之计，比如极端情况，某段时间 API 返回数据挺慢，在限流的时间内还没返回数据，这样 setState 还是有可能把数据展示错乱。关键在于请求 pending 时就切换菜单会出现数据错乱。
如果我们在发新的请求之前能把之前 pending 的请求取消掉就会解决这个问题，这就是 axios 的 CancelToken 所做的事情。
我们在点击菜单项绑定的函数中每次定义下面两个变量
const CancelToken = axios.CancelToken const source = CancelToken.source()  注意上面两个变量初始化时每次切换菜单项时都要重新定义，不然只定义一次的话，上面两个变量的值只是初始化时的值。我们可以把上面两个变量写到我们发送请求的前面，然后把发送请求包装成一个函数，在 componentDidMount() 和 切换菜单项时调用这个函数。然后完整的代码如下。</description>
    </item>
    
    <item>
      <title>当React State 为 Array 时如何 setState</title>
      <link>http://ijs.me/2018/05/08/react-state-array-setstate/</link>
      <pubDate>Tue, 08 May 2018 13:14:20 +0800</pubDate>
      
      <guid>http://ijs.me/2018/05/08/react-state-array-setstate/</guid>
      <description>某个数据类型为 Array 的 state，这里我们假设这个 state 名为 test，然后我们在组件的 constructor 里初始化这个 state:
constructor(props) { super(props) this.state = { test: [] } }  数据使用 WebSocket 通信，当来了新数据时，比如我们接收到的数据为 data, data里有一个或者多个对象的数组，类似于这样 [{},{}], 我们想把data里的数据存到 this.state.test 数组的头部，该怎么做呢，我们不能直接用 unshift 操作，因为 setState 才会触发 render() 函数重新渲染UI。
也不能这样做：
this.setState({ test: this.state.test.unshift(...data) })  因为 unshift 返回的是新的长度，所以上面的做法是错误的。
正确的做法是：
let newTest = this.state.test.unshift(...data) this.setState({ test: newTest })  也可以使用扩展运算符来做：
this.setState({ test: [...data, ...this.state.test] })  ... 是扩展运算符，可以把数组转为用逗号分隔的参数序列。
上面那种做法每次都会新开辟数组的内存空间，如果数据量非常大并且更新很快时，容易造成内存回收不及时而导致页面死掉。所以把新来的数据 data 加到 test 这个 state 的数组的头部更好的方法是使用 concat()</description>
    </item>
    
    <item>
      <title>React 异步引入外部js</title>
      <link>http://ijs.me/2018/05/04/react-script-async/</link>
      <pubDate>Fri, 04 May 2018 18:47:26 +0800</pubDate>
      
      <guid>http://ijs.me/2018/05/04/react-script-async/</guid>
      <description>起因 最近在做项目时，需要用到第三方的人机验证码服务，而这项服务没有npm包，所以就需要引入 &amp;lt;script&amp;gt;，我们只需要在需要在用到这个人机验证服务的component里加入以下代码就可以实现异步加载 &amp;lt;script&amp;gt;：
componentDidMount () { const script = document.createElement(&amp;quot;script&amp;quot;) script.src = &amp;quot;//captcha.luosimao.com/static/dist/api.js&amp;quot; script.async = true document.body.appendChild(script) }  更进一步 你有没有思考过为啥引入外部文件时经常省略 http: 或者 https: 呢，其实这样做是有原因的：
//captcha.luosimao.com/static/dist/api.js 这种写法是相对路径写法，浏览器会自动加上 http: 或者 https:补全为绝对路径，补全原则是与我们当前页面使用的协议相同。</description>
    </item>
    
    <item>
      <title>VS Code 扩展推荐</title>
      <link>http://ijs.me/2018/04/30/vscode-extensions/</link>
      <pubDate>Mon, 30 Apr 2018 23:56:14 +0800</pubDate>
      
      <guid>http://ijs.me/2018/04/30/vscode-extensions/</guid>
      <description>Auto Close Tag: Automatically add HTML/XML close tag, same as Visual Studio IDE or Sublime Text. 写 JSX 时能自动闭合标签，很有用；
Auto Import - ES6, TS, JSX, TSX: Automatically finds, parses and provides code actions and code completion for all available imports. Works with JavaScript and TypeScript. 自动引入代码中用到的组件；
Auto Rename Tag: Automatically rename paired HTML/XML tag, same as Visual Studio IDE does. 修改标签时自动重命名匹配的标签；
Import Cost: Display import/require package size in the editor. 计算 import 进来的模块大小；</description>
    </item>
    
    <item>
      <title>Git 回滚到某一版本</title>
      <link>http://ijs.me/2018/04/25/git-reset-hard/</link>
      <pubDate>Wed, 25 Apr 2018 00:32:03 +0800</pubDate>
      
      <guid>http://ijs.me/2018/04/25/git-reset-hard/</guid>
      <description>起因 这两天写练习项目时用了eslint, 然后发现 yarn add eslint 或者 yarn global add eslint 无效，只能使用 npm install -g eslint 来按安装， eslint --init才会在命令行里起作用，随后发现带来了一些问题，并且感觉Eslint并不是理想的代码规范方式，而且还有丑陋的错误误报，遂决定暂时弃用 Eslint，卸载Eslint后，项目跑的时候总是时不时奇怪的就因为Eslint跑不起来了，所以决定把代码回滚到使用Eslint以前的版本。
显示提交的log $ git log -5 commit 2497b4715fad2f022e5fee3e83341b19d7fa8bf7 Author: xxx &amp;lt;xxx@xxx.com&amp;gt; Date: Mon Apr 23 01:26:54 2018 +0800 aaa commit 23faaf5ba3b5104c3f93275d9441439d31e06a74 Author: xxx &amp;lt;xxx@xxx.com&amp;gt; Date: Sun Apr 22 21:09:42 2018 +0800 bbb commit a0c8880200f8de959a12686faa7ce3b2d37b24b4 Author: xxx &amp;lt;xxx@xxx.com&amp;gt; Date: Sun Apr 22 15:27:55 2018 +0800 ccc commit b736de663899dc24d362d93ebb32f7548402cc5b Author: xxx &amp;lt;xxx@xxx.com&amp;gt; Date: Sat Apr 21 23:19:45 2018 +0800 ddd commit ee7c7a7a6c3bc7f2698b2a0b4b1bcbe0dce93722 Author: xxx &amp;lt;xxx@xxx.</description>
    </item>
    
    <item>
      <title>Git 合并某个分支下的某个文件</title>
      <link>http://ijs.me/2018/04/23/git-merge-branch-file/</link>
      <pubDate>Mon, 23 Apr 2018 23:22:52 +0800</pubDate>
      
      <guid>http://ijs.me/2018/04/23/git-merge-branch-file/</guid>
      <description>查看远程分支 git branch -r  拉取远程分支并创建本地分支 git checkout -b 本地分支名x origin/远程分支名x  合并分支的某个文件 现在我们想把我们刚创建的本地分支 x 的某个文件 file 或者文件夹 folder 内的文件合并到本地开发的分支 develop 上，而不是把整个分支都合并过来，方法如下：
先切换到分支 develop 上
git checkout develop  然后执行
git checkout --patch A file  其中 file 可以换成某个文件夹 folder，然后根据自己的需要按 y 或者 n。</description>
    </item>
    
    <item>
      <title>Hugo 的使用</title>
      <link>http://ijs.me/2018/04/22/hugo-usage/</link>
      <pubDate>Sun, 22 Apr 2018 21:27:08 +0800</pubDate>
      
      <guid>http://ijs.me/2018/04/22/hugo-usage/</guid>
      <description>创建一篇文章 hugo new post/2018/hugo-usage.md  生成的markdown文档头部信息加上 slug 字段表示URL链接信息
本地生成预览 hugo server  生成静态页到 public 文件夹 hugo  部署到Github Pages上 把public文件夹下的内容推送到相应的Github Pages仓库里。</description>
    </item>
    
    <item>
      <title>存储React组件中的数据何时用State或者This</title>
      <link>http://ijs.me/2018/04/10/react-component-data-state-this/</link>
      <pubDate>Tue, 10 Apr 2018 00:59:22 +0800</pubDate>
      
      <guid>http://ijs.me/2018/04/10/react-component-data-state-this/</guid>
      <description>为什么需要this React组件内的数据一般用state来存储，但是如果所有的除props之外的数据都用state来存储的话，前些天做项目时就发现一个问题。
我遇到的那种场景，this.setState改变一个state的值，然后立即去fetch一个url中带有这个state参数的api，就会导致这个state的值是上一次的值，fetch到的数据是旧的，setState执行慢了一点点。本想加个setTimeout延迟几毫秒给解决掉，又一想，这样不是正经程序员所为，就把这个state改为this.x=‘123’这样的属性，这样就能解决setState异步执行带来的问题。
也可以在 setState() 的回调函数里去解决 setState() 异步带来的问题。</description>
    </item>
    
    <item>
      <title>My First Post</title>
      <link>http://ijs.me/2018/04/01/first-post/</link>
      <pubDate>Sun, 01 Apr 2018 04:51:29 +0800</pubDate>
      
      <guid>http://ijs.me/2018/04/01/first-post/</guid>
      <description> 测试 Hugo </description>
    </item>
    
  </channel>
</rss>