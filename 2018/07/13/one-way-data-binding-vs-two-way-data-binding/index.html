<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;"
      name="viewport"
    />
    <meta name="keywords" content="老崔博客，技术博客，前端，前端开发技术，全栈">
    <meta name="description" content="记录学习，知识笔记，每天提高一点点。">
    <title>单向数据绑定 VS 双向数据绑定</title>
    <link rel="stylesheet" href="http://static.intj.top/tomorrow.min.css" />
    <link
      rel="stylesheet"
      type="text/css"
      href="/css/main.css"
    />
    
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=UA-122652961-1"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || []
      function gtag() {
        dataLayer.push(arguments)
      }
      gtag("js", new Date())

      gtag("config", "UA-122652961-1")
    </script>
  </head>
  <body>


  <main class="container" role="main">
    <div class="article-head">
      <h1>单向数据绑定 VS 双向数据绑定</h1>
      <span class="blog-post-date">July 13, 2018</span>
    </div>
    <div class="blog-post-content">
        

<h2 id="单向数据绑定">单向数据绑定</h2>

<p>React 的数据是单向绑定的，不像 Vue 支持双向绑定。相应的 React 中的数据流也是单向的，这也是 React 提倡的一点，单向数据绑定能够避免状态管理复杂度上升时产生的各种问题。试想一下在双向数据绑定中：如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。单向数据绑定可以让应用变得更加可预测且容易理解。</p>

<p>单向数据绑定的优点：</p>

<ol>
<li>所有状态的改变可记录、可跟踪，源头易追溯;</li>
<li>所有数据只有一份，组件数据只有唯一的入口和出口，使得程序更直观更容易理解，有利于应用的可维护性;</li>
<li>一旦数据变化，就去更新页面(data-页面)，但是没有(页面-data);</li>
<li>如果用户在页面上做了变动，那么就手动收集起来(双向是自动)，合并到原有的数据中。</li>
</ol>

<p>双向绑定 = 单向绑定 + UI事件监听</p>

<p>单向数据绑定的缺点：</p>

<ol>
<li>HTML代码渲染完成，无法改变，有新数据，就须把旧HTML代码去掉，整合新数据和模板重新渲染;</li>
<li>代码量上升，数据流转过程变长，出现很多类似的样板代码;</li>
<li>同时由于对应用状态独立管理的严格要求(单一的全局store)，在处理局部状态较多的场景时(如用户输入交互较多的“富表单型”应用 TodoMVC等)，会显得啰嗦及繁琐。</li>
</ol>

<h2 id="双向数据绑定">双向数据绑定</h2>

<p>双向数据绑定带来了双向数据流，数据模型（Module）和视图（View）之间的双向绑定，无论数据变化，或是用户操作，都能带来互相的变动，自动更新，适用于UI控件中（通常是类表单操作）。</p>

<p>双向数据绑定优点：</p>

<ol>
<li>用户在视图上的修改会自动同步到数据模型中去，数据模型中值的变化也会立刻同步到视图中去；</li>
<li>无需进行和单向数据绑定的那些CRUD（Create，Retrieve，Update，Delete）操作；</li>
<li>在表单交互较多的场景下，会简化大量业务无关的代码。</li>
</ol>

<p>双向数据绑定缺点：</p>

<ol>
<li>无法追踪局部状态的变化；</li>
<li>“暗箱操作”，增加了出错时 debug 的难度；</li>
<li>由于组件数据变化来源入口变得可能不止一个，数据流转方向易紊乱，若再缺乏“管制”手段，血崩。</li>
</ol>

    </div>
  </main>

  <footer>
    <a href="https://github.com/cuidezhu" target="_blank">
      <svg height="32" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="32" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg>
    </a>
  </footer>
  <script src="http://static.intj.top/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>